#!/usr/bin/env bun

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';

/**
 * Get project root directory (where package.json is)
 */
export function getProjectRoot(): string {
  let current = process.cwd();
  while (current !== '/') {
    if (existsSync(join(current, 'package.json'))) {
      // Verify it's a Fred project
      try {
        const pkg = readJsonFile(join(current, 'package.json'));
        if (pkg.dependencies?.fred || pkg.devDependencies?.fred) {
          return current;
        }
      } catch {
        // Continue searching
      }
    }
    current = dirname(current);
  }
  throw new Error('Not in a Fred project. Please run this command from your project root.');
}

/**
 * Read and parse JSON file
 */
export function readJsonFile<T = any>(path: string): T {
  const content = readFileSync(path, 'utf-8');
  return JSON.parse(content);
}

/**
 * Write JSON file with formatting
 */
export function writeJsonFile(path: string, data: any): void {
  const content = JSON.stringify(data, null, 2) + '\n';
  writeFileSync(path, content, 'utf-8');
}

/**
 * Read text file
 */
export function readTextFile(path: string): string {
  return readFileSync(path, 'utf-8');
}

/**
 * Write text file
 */
export function writeTextFile(path: string, content: string): void {
  writeFileSync(path, content, 'utf-8');
}

/**
 * Add import to TypeScript file
 */
export function addImport(filePath: string, importStatement: string): void {
  const content = readTextFile(filePath);
  
  // Check if import already exists
  if (content.includes(importStatement)) {
    return;
  }
  
  // Find the last import statement
  const importRegex = /^import\s+.*?from\s+['"].*?['"];?$/gm;
  const imports = content.match(importRegex) || [];
  
  if (imports.length === 0) {
    // No imports, add at the top
    const lines = content.split('\n');
    lines.splice(0, 0, importStatement);
    writeTextFile(filePath, lines.join('\n'));
    return;
  }
  
  // Find the last import line
  const lastImport = imports[imports.length - 1];
  const lastImportIndex = content.lastIndexOf(lastImport);
  const nextLineIndex = content.indexOf('\n', lastImportIndex + lastImport.length);
  
  // Insert after last import
  const before = content.substring(0, nextLineIndex);
  const after = content.substring(nextLineIndex);
  writeTextFile(filePath, before + '\n' + importStatement + after);
}

/**
 * Add code after a search pattern
 */
export function addCodeAfter(filePath: string, searchPattern: string, newCode: string): void {
  const content = readTextFile(filePath);
  
  // Check if code already exists
  if (content.includes(newCode.trim())) {
    return;
  }
  
  const patternIndex = content.indexOf(searchPattern);
  if (patternIndex === -1) {
    throw new Error(`Pattern not found in file: ${searchPattern}`);
  }
  
  // Find the end of the line containing the pattern
  const lineEnd = content.indexOf('\n', patternIndex);
  const before = content.substring(0, lineEnd + 1);
  const after = content.substring(lineEnd + 1);
  
  // Add new code with proper indentation
  const indent = getIndentation(content, patternIndex);
  const indentedCode = newCode.split('\n').map(line => indent + line).join('\n');
  
  writeTextFile(filePath, before + indentedCode + '\n' + after);
}

/**
 * Get indentation at a specific position
 */
function getIndentation(content: string, position: number): string {
  const lineStart = content.lastIndexOf('\n', position) + 1;
  const line = content.substring(lineStart, position);
  const match = line.match(/^(\s*)/);
  return match ? match[1] : '';
}

/**
 * Update .env.example file
 */
export function updateEnvExample(envVar: string, value: string = ''): void {
  const projectRoot = getProjectRoot();
  const envPath = join(projectRoot, '.env.example');
  
  let content = '';
  if (existsSync(envPath)) {
    content = readTextFile(envPath);
  }
  
  // Check if variable already exists
  const regex = new RegExp(`^${envVar}=.*$`, 'm');
  if (regex.test(content)) {
    // Update existing
    content = content.replace(regex, `${envVar}=${value}`);
  } else {
    // Add new
    if (content && !content.endsWith('\n')) {
      content += '\n';
    }
    content += `${envVar}=${value}\n`;
  }
  
  writeTextFile(envPath, content);
}

/**
 * Remove from .env.example file
 */
export function removeFromEnvExample(envVar: string): void {
  const projectRoot = getProjectRoot();
  const envPath = join(projectRoot, '.env.example');
  
  if (!existsSync(envPath)) {
    return;
  }
  
  const content = readTextFile(envPath);
  const regex = new RegExp(`^${envVar}=.*$\\n?`, 'm');
  const updated = content.replace(regex, '');
  writeTextFile(envPath, updated);
}

/**
 * Get provider package name
 */
export function getProviderPackageName(provider: string): string {
  const providerMap: Record<string, string> = {
    openai: '@ai-sdk/openai',
    groq: '@ai-sdk/groq',
    anthropic: '@ai-sdk/anthropic',
    google: '@ai-sdk/google',
    mistral: '@ai-sdk/mistral',
    cohere: '@ai-sdk/cohere',
    vercel: '@ai-sdk/vercel',
    'azure-openai': '@ai-sdk/azure-openai',
    'azure-anthropic': '@ai-sdk/azure-anthropic',
    azure: '@ai-sdk/azure-openai',
    fireworks: '@ai-sdk/fireworks',
    xai: '@ai-sdk/xai',
    ollama: '@ai-sdk/ollama',
    ai21: '@ai-sdk/ai21',
    nvidia: '@ai-sdk/nvidia',
    bedrock: '@ai-sdk/amazon-bedrock',
    'amazon-bedrock': '@ai-sdk/amazon-bedrock',
    cloudflare: '@ai-sdk/cloudflare',
    elevenlabs: '@ai-sdk/elevenlabs',
    lepton: '@ai-sdk/lepton',
    perplexity: '@ai-sdk/perplexity',
    replicate: '@ai-sdk/replicate',
    together: '@ai-sdk/together',
    upstash: '@ai-sdk/upstash',
  };
  
  return providerMap[provider.toLowerCase()] || `@ai-sdk/${provider.toLowerCase()}`;
}

/**
 * Get environment variable name for provider
 */
export function getProviderEnvVar(provider: string): string {
  const envMap: Record<string, string> = {
    openai: 'OPENAI_API_KEY',
    groq: 'GROQ_API_KEY',
    anthropic: 'ANTHROPIC_API_KEY',
    google: 'GOOGLE_API_KEY',
    mistral: 'MISTRAL_API_KEY',
    cohere: 'COHERE_API_KEY',
    vercel: 'VERCEL_API_KEY',
    'azure-openai': 'AZURE_OPENAI_API_KEY',
    'azure-anthropic': 'AZURE_ANTHROPIC_API_KEY',
    azure: 'AZURE_OPENAI_API_KEY',
    fireworks: 'FIREWORKS_API_KEY',
    xai: 'XAI_API_KEY',
    ollama: 'OLLAMA_API_KEY',
    ai21: 'AI21_API_KEY',
    nvidia: 'NVIDIA_API_KEY',
    bedrock: 'AWS_ACCESS_KEY_ID',
    'amazon-bedrock': 'AWS_ACCESS_KEY_ID',
    cloudflare: 'CLOUDFLARE_API_KEY',
    elevenlabs: 'ELEVENLABS_API_KEY',
    lepton: 'LEPTON_API_KEY',
    perplexity: 'PERPLEXITY_API_KEY',
    replicate: 'REPLICATE_API_KEY',
    together: 'TOGETHER_API_KEY',
    upstash: 'UPSTASH_API_KEY',
  };
  
  return envMap[provider.toLowerCase()] || `${provider.toUpperCase()}_API_KEY`;
}

/**
 * Get default model for provider
 */
export function getDefaultModel(provider: string): string {
  const modelMap: Record<string, string> = {
    openai: 'gpt-4o-mini',
    groq: 'llama-3.1-70b-versatile',
    anthropic: 'claude-3-5-sonnet-20241022',
    google: 'gemini-1.5-flash',
    mistral: 'mistral-small-latest',
    cohere: 'command-r',
    vercel: 'claude-3-5-sonnet-20241022',
    'azure-openai': 'gpt-4o-mini',
    'azure-anthropic': 'claude-3-5-sonnet-20241022',
    azure: 'gpt-4o-mini',
    fireworks: 'llama-v3-70b-instruct',
    xai: 'grok-beta',
    ollama: 'llama3.2',
    ai21: 'j2-ultra',
    nvidia: 'meta/llama-3-70b-instruct',
    bedrock: 'anthropic.claude-3-5-sonnet-20241022-v2:0',
    'amazon-bedrock': 'anthropic.claude-3-5-sonnet-20241022-v2:0',
    cloudflare: 'llama-3-70b-instruct',
    elevenlabs: 'eleven_turbo_v2_5',
    lepton: 'llama-3-70b-instruct',
    perplexity: 'llama-3.1-sonar-large-128k-online',
    replicate: 'meta/llama-3-70b-instruct',
    together: 'meta/llama-3-70b-instruct',
    upstash: 'meta/llama-3-70b-instruct',
  };

  return modelMap[provider.toLowerCase()] || 'gpt-4o-mini';
}

/**
 * Validate kebab-case identifier
 */
export function validateKebabCase(id: string): { valid: boolean; error?: string } {
  if (!id || id.trim().length === 0) {
    return { valid: false, error: 'Identifier cannot be empty' };
  }
  
  if (!/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(id)) {
    return { valid: false, error: 'Identifier must be in kebab-case (lowercase letters, numbers, and hyphens)' };
  }
  
  return { valid: true };
}

/**
 * Convert to kebab-case
 */
export function toKebabCase(str: string): string {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}
